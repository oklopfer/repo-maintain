#!/bin/bash

# Colors
if [[ -z $NO_COLOR ]]; then
  export RED=$'\033[0;31m'
  export GREEN=$'\033[0;32m'
  export YELLOW=$'\033[0;33m'
  export BLUE=$'\033[0;34m'
  export PURPLE=$'\033[0;35m'
  export CYAN=$'\033[0;36m'
  export WHITE=$'\033[0;37m'
  export BGreen=$'\033[1;32m'
  export BCyan=$'\033[1;36m'
  export BYellow=$'\033[1;33m'
  export BPurple=$'\033[1;35m'
  export BRed=$'\033[1;31m'
  export BWhite=$'\033[1;37m'
  export NC=$'\033[0m'
fi

function show_help() {
  cat <<EOF
${BYellow}Usage:${NC} $0 ${PURPLE}[OPTIONS]${NC}

${BYellow}Options:${NC}

  ${BGreen}-V/-v, --version${NC}  Image version tag
                    (default: ${CYAN}current date in YYYYMMDD format${NC})

  ${BGreen}-A/-a, --arch${NC}     Target architecture
                    (options: ${CYAN}aarch64, amd64, arm64, x86_64${NC}, default: ${CYAN}auto-detect${NC})

  ${BGreen}-T/-t, --test${NC}     ${YELLOW}Promptless:${NC} fully build and start up the image
                    (default: ${CYAN}disabled${NC})

  ${BGreen}-C/-c, --clean${NC}    Use --no-cache during Docker build
                    (default: ${CYAN}disabled${NC})

  ${BGreen}-F/-f, --file${NC}     ${YELLOW}Promptless:${NC} Create only the Dockerfile, with instructions
                    (default: ${CYAN}prompted${NC})

  ${BGreen}-H/-h, --help${NC}     Show this help message

${BYellow}Description:${NC}

  This script helps to easily build and test Rhino Linux Docker images.

${BYellow}Examples:${NC}

  ${BPurple}$0 -t -c -v 2023.4 -a arm64${NC}
    
    Builds and boots arm64v8/rhinolinux:2023.4 from scratch.
    Note: the version tag may not correlate with the actual
    Rhino Linux version. This option is meant for easily 
    publishing images for specific milestones.


  ${BPurple}$0 --file -A x86_64${NC}
    
    Creates a Dockerfile for amd64/rhinolinux:YYYYMMDD and
    provides instructions on how to build and run the image.

EOF
}

test_mode=0
no_cache=""

while (($# > 0)); do
  key="$1"
  case $key in
    -V | -v | --version)
      imgver="$2"
      shift
      shift
      ;;
    -A | -a | --arch)
      darcher="$2"
      shift
      shift
      ;;
    -T | -t | --test)
      DISABLE_PROMPTS="yes"
      test_mode=1
      shift
      ;;
    -C | -c | --clean)
      no_cache="--no-cache"
      shift
      shift
      ;;
    -F | -f | --file)
      if ((test_mode == 0)); then
        DISABLE_PROMPTS="yes"
      else
        echo "${BRed}Nope.${NC} ${YELLOW}File is the opposite of Test.${NC}"
        exit 1
      fi
      shift
      shift
      ;;
    -H | -h | --help)
      show_help
      exit 1
  esac
done

function ask() {
  local prompt default reply

  if [[ ${2-} == 'Y' ]]; then
    prompt="${BGreen}Y${NC}/${BRed}n${NC}"
    default='Y'
  elif [[ ${2-} == 'N' ]]; then
    prompt="${BGreen}y${NC}/${BRed}N${NC}"
    default='N'
  else
    prompt="${BGreen}y${NC}/${BRed}n${NC}"
  fi

  # Ask the question (not using "read -p" as it uses stderr not stdout)
  echo -ne "$1 [$prompt] "

  if [[ ${DISABLE_PROMPTS:-z} == "z" ]]; then
    export DISABLE_PROMPTS="no"
  fi

  if [[ $DISABLE_PROMPTS == "no" ]]; then
    read -r reply <&0
    # Detect if script is running non-interactively
    # Which implies that the input is being piped into the script
    if [[ $NON_INTERACTIVE ]]; then
      if [[ -z $reply ]]; then
        echo -n "$default"
      fi
      echo "$reply"
    fi
  else
    echo "$default"
    reply=$default
  fi

  # Default?
  if [[ -z $reply ]]; then
    reply=$default
  fi

  while :; do
    # Check if the reply is valid
    case "$reply" in
      Y* | y*)
        export answer=1
        return 0 #return code for backwards compatibility
        break
        ;;
      N* | n*)
        export answer=0
        return 1 #return code
        break
        ;;
      *)
        echo -ne "$1 [$prompt] "
        read -r reply < /dev/tty
        ;;
    esac
  done
}

if [[ -z ${imgver} ]]; then
  imgver="$(date +%Y%m%d)"
fi

if [[ -z ${darcher} ]]; then
  if [[ $(uname -m) == "aarch64" || $(uname -m) == "arm64" ]]; then
    darcher="arm64"
  elif [[ $(uname -m) == "x86_64" || $(uname -m) == "amd64" ]]; then
    darcher="amd64"
  else
    echo "Rhino Linux only supports x86_64/amd64 + aarch64/arm64 as base architectures!"
    exit 1
  fi
fi

if [[ ${darcher} == "aarch64" || $darcher == "arm64" ]]; then
  darcher="arm64"
elif [[ ${darcher} == "x86_64" || $darcher == "amd64" ]]; then
  darcher="amd64"
else
  echo "Rhino Linux only supports x86_64/amd64 + aarch64/arm64 as base architectures!"
  exit 1
fi

if [[ ${darcher} == "arm64" ]]; then
  base_darch="arm64v8/"
elif [[ ${darcher} == "amd64" ]]; then
  base_darch="amd64/"
else
  echo "Rhino Linux only supports x86_64/amd64 + aarch64/arm64 as base architectures!"
  exit 1
fi

built_dock="$(pwd)/Dockerfile.RhinoLinux.${imgver}_${darcher}"

if [[ -f ${built_dock} ]]; then
  rm -f ${built_dock}
fi

cat > ${built_dock} << EOF
FROM ${base_darch}ubuntu:devel
LABEL org.opencontainers.image.description "Contains Rhino Linux ${imgver}"

SHELL ["/bin/bash", "-l", "-c"]
ARG DEBIAN_FRONTEND=noninteractive
ENV TZ="Africa/Libreville"
RUN ln -snf /usr/share/zoneinfo/\$TZ /etc/localtime && echo \$TZ > /etc/timezone
ARG package="pacstall"

RUN if [[ \$(dpkg --print-architecture) == "amd64" ]]; then dpkg --add-architecture i386; fi && apt-get update && apt-get dist-upgrade -y && apt-get install wget curl git sudo nano ca-certificates util-linux lsb-release adduser dpkg-dev apt-utils -y --fix-missing --no-install-recommends && apt-get clean && apt-get autoclean && apt-get autoremove -y
RUN VERSION_CODENAME="\$(lsb_release -cs)" && sudo sed -i "s/\$VERSION_CODENAME/.\/devel/g" /etc/apt/sources.list && sudo apt-get update
RUN adduser --disabled-password --gecos '' rhino && adduser rhino sudo
RUN sudo bash -c "\$(curl -fsSL https://pacstall.dev/q/install\?dnt || wget -q https://pacstall.dev/q/install\?dnt -O -)" && rm -f /var/cache/apt/archives/*.deb /var/cache/apt/archives/partial/*.deb /var/cache/apt/*.bin
RUN echo '%sudo ALL=(ALL) NOPASSWD:ALL' >> /etc/sudoers
RUN chown -R rhino:rhino /var/log/pacstall && chown -R rhino:rhino /tmp/pacstall
RUN chown -R rhino:rhino /var/log/pacstall && chown -R rhino:rhino /tmp/pacstall
RUN runuser -l rhino -c 'HOME=/home/rhino SUDO_USER=rhino PACSTALL_DOWNLOADER=quiet-wget pacstall -PI nala-deb rhino-server-core'
RUN echo "neofetch" >> /home/rhino/.bashrc
# https://askubuntu.com/a/1026978
RUN rm /etc/apt/apt.conf.d/docker-clean

USER rhino
WORKDIR /home/rhino

# ENTRYPOINT ["/bin/bash"]
CMD ["bash"]
EOF

if ((test_mode == 1)); then
  echo "${BYellow}Built${NC} ${BPurple}${built_dock}${BYellow}. Building${NC} ${BPurple}${base_darch}rhinolinux:${imgver}${BYellow}...${NC}"
  docker build -f ${built_dock} -t ${base_darch}rhinolinux:${imgver} . ${no_cache} && \
  echo "${BYellow}Built${NC} ${BPurple}${base_darch}rhinolinux:${imgver}${BYellow}. Starting...${NC}" && \
  docker run -it --net=host ${base_darch}rhinolinux:${imgver} bash
else
  ask "Start build now?" N
  if ((answer == 0)); then
    echo "${BYellow}Not starting. Run the following command to build:${NC}"
    echo "${GREEN}docker build -f ${built_dock} -t ${base_darch}rhinolinux:${imgver} . --no-cache${NC}"
    echo "${BYellow}After the build has complete, run the following command to test the image:${NC}"
    echo "${GREEN}docker run -it --net=host ${base_darch}rhinolinux:${imgver} bash${NC}"
  else
    docker build -f ${built_dock} -t ${base_darch}rhinolinux:${imgver} . ${no_cache} && \
    ask "Build complete. Do you want to start the image to test?" N
    if ((answer == 0)); then
      echo "${BYellow}Not starting. Run the following command to test:${NC}"
      echo "${GREEN}docker run -it --net=host ${base_darch}rhinolinux:${imgver} bash${NC}"
    else
      docker run -it --net=host ${base_darch}rhinolinux:${imgver} bash
    fi
  fi
fi